// Generated by CoffeeScript 1.6.3
(function() {
  var command, copySkeleton, dlog, eco, exec, exitErr, fs, getGitSkeleton, getHttpSkeleton, getSkeleton, guessType, http, inTempDir, path, skeleton, temp, unpack, wrench;

  fs = require('fs');

  path = require('path');

  http = require('http');

  exec = require('child_process').exec;

  dlog = require('debug')('perc:init');

  eco = require('eco');

  temp = require('temp');

  wrench = require('wrench');

  skeleton = path.join(__dirname, '../../skeleton');

  module.exports = command = {
    help: "Initialize a project from a skeleton",
    init: function(command, config) {
      var plist;
      plist = function(val) {
        var n, pair, props, v, _i, _len, _ref, _ref1;
        props = {};
        _ref = val.split(',');
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          pair = _ref[_i];
          _ref1 = pair.split(':'), n = _ref1[0], v = _ref1[1];
          props[n] = v;
        }
        return props;
      };
      command.option('-S, --skeleton [SKELETON]', 'Skeleton path or url', skeleton);
      command.option('--set [NAME:VALUE,NAME:VALUE]', 'Set project package config variable', plist);
      return command.usage("<path> [options]\n\n  " + this.help);
    },
    run: function(command, config, args) {
      var opts, _ref;
      opts = {
        source: command.skeleton,
        skeleton: command.skeleton,
        target: path.resolve((_ref = args[0]) != null ? _ref : process.cwd()),
        set: command.set
      };
      return getSkeleton(opts);
    }
  };

  getSkeleton = function(opts) {
    var type;
    type = guessType(opts.skeleton);
    if (type === 'http') {
      return getHttpSkeleton(opts, copySkeleton);
    } else if (type === 'git') {
      return getGitSkeleton(opts, copySkeleton);
    } else {
      return copySkeleton(opts);
    }
  };

  copySkeleton = function(opts, next) {
    var pkg, ppath, prop, val, wopts, _ref;
    if (next == null) {
      next = (function() {});
    }
    dlog("Copy " + opts.skeleton + " to " + opts.target);
    wopts = {
      preserve: true,
      preserveFiles: true,
      filter: /~$/,
      excludeHiddenUnix: true,
      whitelist: false
    };
    wrench.copyDirSyncRecursive(opts.skeleton, opts.target, wopts);
    console.log("Copied skeleton from " + opts.source + " into " + opts.target);
    if (opts.set) {
      ppath = path.join(opts.target, 'package.json');
      pkg = JSON.parse(fs.readFileSync(ppath, 'utf-8'));
      _ref = opts.set;
      for (prop in _ref) {
        val = _ref[prop];
        pkg[prop] = val;
      }
      fs.writeFileSync(ppath, JSON.stringify(pkg));
      console.log("Set package.json properties: " + ("" + ([
        (function() {
          var _ref1, _results;
          _ref1 = opts.set;
          _results = [];
          for (prop in _ref1) {
            val = _ref1[prop];
            _results.push(prop);
          }
          return _results;
        })()
      ].join(', '))));
    }
    return next(opts);
  };

  getHttpSkeleton = function(opts, next) {
    return inTempDir(function(dirPath, clean) {
      console.log("Downloading skeleton from " + opts.skeleton + "...");
      return http.get(opts.skeleton, function(res) {
        var pkg, pkgFile, pkgPath;
        pkgFile = path.join(dirPath, 'pkg.tgz');
        pkgPath = path.join(dirPath, 'pkg');
        dlog("Downloading " + opts.skeleton + " to " + pkgFile);
        pkg = fs.createWriteStream(pkgFile);
        res.on('error', function(error) {
          dlog("Http error " + error);
          clean();
          return exitErr(error);
        });
        res.on('data', function(chunk) {
          dlog("data " + chunk.length + " bytes");
          return pkg.write(chunk);
        });
        return res.on('end', function() {
          console.log("Download complete");
          pkg.end();
          return unpack(pkgFile, pkgPath, clean, function(unpacked) {
            opts.skeleton = unpacked;
            return next(opts, clean);
          });
        });
      });
    });
  };

  getGitSkeleton = function(opts, next) {
    return inTempDir(function(dirPath, clean) {
      var pkgPath,
        _this = this;
      console.log("Cloning " + opts.skeleton + "...");
      pkgPath = path.join(dirPath, 'pkgDir');
      return exec("git clone " + opts.skeleton + " " + pkgPath, function(error, stdout, stderr) {
        dlog("cloned " + opts.skeleton + " into " + pkgPath);
        if (error) {
          clean();
          exitErr(error);
        }
        console.log("Clone complete");
        opts.skeleton = pkgPath;
        return next(opts, clean);
      });
    });
  };

  inTempDir = function(next) {
    var _this = this;
    return temp.mkdir('perc-init', function(err, dirPath) {
      var clean;
      if (err) {
        exitErr(err);
      }
      clean = function() {
        wrench.rmdirSyncRecursive(dirPath);
        return dlog("Removed " + dirPath);
      };
      process.on('uncaughtException', function(err) {
        clean();
        return exitErr(err);
      });
      return next(dirPath, clean);
    });
  };

  guessType = function(dirOrUrl) {
    var e, st;
    try {
      st = fs.lstatSync(dirOrUrl);
      if (st.isDirectory()) {
        return 'directory';
      } else {
        return exitErr("" + dirOrUrl + " exists but is not a directory");
      }
    } catch (_error) {
      e = _error;
      if (dirOrUrl.match(/^https?:\/\/.*gz$/)) {
        dlog("Guessing http");
        return 'http';
      } else if (dirOrUrl.match('^(git|https?):\/\/')) {
        dlog("Guessing git");
        return 'git';
      } else {
        return exitErr("Can't figure out what " + dirOrUrl + " is");
      }
    }
  };

  exitErr = function(err) {
    dlog("Error " + err);
    console.error("Init failed: " + err);
    return process.exit(1);
  };

  unpack = function(pkg, pkgPath, clean, next) {
    var targz;
    targz = require('tar.gz');
    return new targz().extract(pkg, pkgPath, function(err) {
      var files;
      if (err) {
        clean();
        exitErr(err);
      }
      dlog("Unpacked " + pkg + " to " + pkgPath);
      files = fs.readdirSync(pkgPath);
      skeleton = files.length === 1 ? path.join(pkgPath, files[0]) : pkgPath;
      dlog("Skeleton dir is " + skeleton);
      return next(skeleton);
    });
  };

}).call(this);
