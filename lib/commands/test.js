// Generated by CoffeeScript 1.6.3
(function() {
  var Mocha, coffee, command, dlog, fs, glob, modin, path, setupCoverage, setupDOM,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  path = require('path');

  coffee = require('coffee-script');

  dlog = require('debug')('perc:test');

  glob = require('glob');

  Mocha = require('mocha');

  module.exports = command = {
    help: "Run unit tests",
    init: function(command, config) {
      command.option('-S, --types [TYPES]', 'Set types of test to load');
      command.option('-C, --cover', 'Output coverage report', false);
      command.option('-G, --grep [PATTERN]', 'Only run tests matching pattern');
      command.option('-R, --reporter [REPORTER]', 'Set the mocha reporter', 'spec');
      command.option('-U, --ui [MOCHA_UI]', 'Set mocha ui (default: bdd)', 'bdd');
      command.option('-T, --timeout [TEST_TIMEOUT]', 'Set test timeout');
      command.option('--no-initdom', 'Do not set up jsdom "window" before tests');
      command.option('--no-ignoreleaks', 'Do not ignore leaks of globals');
      return command.usage("<modules> [options]\n\n  " + this.help);
    },
    run: function(command, config, args) {
      var cover, coverageFile, grep, helper, ignoreLeaks, initdom, mocha, modules, mopts, reporter, specfile, timeout, typere, types, ui, _i, _len, _ref;
      types = command.types || config.test.types || 'spec,unit,functional';
      reporter = command.reporter || config.test.reporter || 'spec';
      timeout = command.timeout || config.test.timeout || 6000;
      if (args.length > 1) {
        modules = args.slice(0, -1);
      }
      grep = command.grep || config.test.grep || null;
      initdom = command.initdom;
      ui = config.test.ui || command.ui;
      ignoreLeaks = command.ignoreleaks;
      cover = command.cover;
      coverageFile = config.test.coverageFile || 'coverage.html';
      dlog('test', modules);
      if (cover) {
        if (!/cov/.test(reporter)) {
          helper = require('../coverage');
          reporter = helper(reporter, coverageFile);
        }
      }
      mopts = {
        reporter: reporter,
        ui: ui,
        timeout: timeout,
        ignoreLeaks: ignoreLeaks
      };
      if (grep) {
        mopts.grep = grep;
      }
      typere = new RegExp("\\." + (types.replace(',', '|')) + "\\.");
      mocha = new Mocha(mopts);
      _ref = glob.sync(config.test.cases);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        specfile = _ref[_i];
        if (!specfile.match(typere)) {
          dlog("${specfile} does not match types list, skipped");
          continue;
        }
        if (!modules || modin(config, specfile, modules)) {
          mocha.addFile(specfile);
        } else {
          dlog("${specfile} not in module list, skipped");
        }
      }
      if (initdom) {
        setupDOM();
      }
      if (cover) {
        setupCoverage(config);
      } else {
        require('../require-hook');
      }
      return mocha.run(function(failures) {
        dlog("Mocha callback, failures " + failures);
        return process.exit(failures);
      });
    }
  };

  setupDOM = function() {
    var jsdom;
    jsdom = require('jsdom');
    global.window = jsdom.jsdom().createWindow('<html><body></body></html>');
    global.document = global.window.document;
    return global.navigator = {
      userAgent: "nodejs",
      platform: "nodejs",
      product: "nodejs"
    };
  };

  setupCoverage = function(config) {
    var cover, coverage, minimatch;
    coverage = require('coffee-coverage');
    minimatch = require('minimatch');
    cover = new coverage.CoverageInstrumentor();
    return require.extensions['.coffee'] = function(module, filename) {
      var content, file, opts, result;
      file = fs.readFileSync(filename, 'utf8');
      opts = {
        filename: filename
      };
      if (minimatch(filename, "**/" + config.test.cases)) {
        content = coffee.compile(file, opts);
        return module._compile(content, filename);
      }
      result = cover.instrumentCoffee(filename, file);
      return module._compile(result.init + result.js, filename);
    };
  };

  modin = function(config, filename, modules) {
    var abs, noext, rel;
    abs = path.resolve(config.root, filename);
    rel = path.relative(config.root, abs);
    noext = rel.indexOf('.coffee') !== -1 ? rel.substr(0, rel.indexOf('.coffee')) : rel;
    return __indexOf.call(modules, rel) >= 0 || __indexOf.call(modules, noext) >= 0;
  };

}).call(this);
