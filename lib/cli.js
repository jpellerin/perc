// Generated by CoffeeScript 1.6.3
(function() {
  var customOrHelp, defaultConfig, dlog, extend, fs, loadConfig, path, safeRequire, _safeRequire,
    __slice = [].slice;

  path = require('path');

  fs = require('fs');

  extend = require('extend');

  dlog = require('debug')('perc:cli');

  defaultConfig = {
    build: {
      sources: 'lib',
      sourcePattern: '**/*.coffee',
      output: 'static/app.js'
    },
    check: {
      dir: 'sanity',
      test: 'test.html'
    },
    test: {
      cases: 'spec/**/*.coffee'
    }
  };

  exports.run = function(argv, commands) {
    var config, mod, name, opts, parsed, pkg, program, runf, _fn;
    dlog("run", argv, commands);
    pkg = JSON.parse(fs.readFileSync(__dirname + '/../package.json', 'utf8'));
    program = require('commander');
    program.usage('[options] command <command arguments...> <command options...>' + '\n\n  For help on individual commands, enter perc command --help').version(pkg.version).option('-c, --config [FILE]', 'Config file', 'package.json').option('-s, --section [SECTION]', 'perc config key in config file', 'perc').option('-v, --verbose', 'Be more verbose', false);
    program._name = 'perc';
    program.gotCommand = false;
    program.command('help').usage('').description('Print usage information').action(function() {
      program.gotCommand = true;
      return program.help();
    });
    parsed = program.parseOptions(program.normalize(process.argv.slice(2)));
    config = loadConfig(program.config, program.section);
    runf = {};
    _fn = function(name, mod) {
      var cmd, _ref;
      cmd = program.command((_ref = mod.command) != null ? _ref : name).description(mod.help).action(function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        dlog('run command action', name);
        program.gotCommand = true;
        return mod.run(cmd, config, args);
      });
      return mod.init(cmd, config);
    };
    for (name in commands) {
      mod = commands[name];
      _fn(name, mod);
    }
    program.command('*').description('Custom commmand modules are supported').usage('A custom command module\'s exports must be a function that\n\
           takes the arguments `program` and `config` and returns an exit code. \n\
           perc will look for the module in the current working directory,\n\
           then the module prefixed with `perc-`, and then look for both of\n\
           those variants in the node/npm load path.').action(function() {
      var args, name, program;
      name = arguments[0], program = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      program.gotCommand = true;
      return process.exit(customOrHelp.apply(null, [name, program, config].concat(__slice.call(args))));
    });
    opts = program.parseArgs(parsed.args, parsed.unknown);
    if (!program.gotCommand) {
      dlog("Did not get a command");
      return customOrHelp(null, program, config);
    }
  };

  loadConfig = function(config, section) {
    var configPath, e, pkg;
    if (config == null) {
      config = 'package.json';
    }
    if (section == null) {
      section = 'perc';
    }
    configPath = path.resolve(config);
    dlog(configPath);
    if (fs.existsSync(configPath)) {
      try {
        pkg = require(configPath);
      } catch (_error) {
        e = _error;
        console.error("Error reading config file " + config);
        JSON.parse(fs.readFileSync(configPath, 'utf8'));
      }
    } else {
      pkg = {};
    }
    dlog(pkg);
    config = defaultConfig;
    extend(true, config, pkg[section] || {});
    config.root = path.dirname(configPath);
    config.configPath = configPath;
    dlog(config);
    return config;
  };

  customOrHelp = function() {
    var args, config, cwd, mod, name, names, program;
    name = arguments[0], program = arguments[1], config = arguments[2], args = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    dlog("custom or help " + name, program, args);
    if (name) {
      cwd = process.cwd();
      names = ["" + cwd + "/" + name, "" + cwd + "/perc-" + name, name, "perc-" + name];
      mod = safeRequire(names);
      if (mod) {
        return mod.apply(null, [program, config].concat(__slice.call(args)));
      } else {
        console.error("Command module '" + name + "' not found");
        console.error("Tried: " + (names.join(', ')));
        program.outputHelp();
        return process.exit(1);
      }
    } else {
      console.error("A command is required");
      program.outputHelp();
      return process.exit(1);
    }
  };

  safeRequire = function(names) {
    var mod, name, _i, _len;
    for (_i = 0, _len = names.length; _i < _len; _i++) {
      name = names[_i];
      mod = _safeRequire(name);
      dlog("safeRequire " + name + ": " + mod);
      if (mod) {
        return mod;
      }
    }
  };

  _safeRequire = function(name) {
    var e;
    try {
      return require(name);
    } catch (_error) {
      e = _error;
      dlog("require " + name + ": " + e);
      if (e.code === 'MODULE_NOT_FOUND') {
        return null;
      } else {
        throw e;
      }
    }
  };

  return null;

}).call(this);
